// appointment/controller.go
package appointment

import (
    "capstone-project/config"
    "capstone-project/controller/ws"
    "capstone-project/entity"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
)

const (
    doctorPrefix  = "d:"
    patientPrefix = "p:"
)

// ========== ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà ==========
func CreateAppointment(c *gin.Context) {
    var req struct {
        Title          string    `json:"title"`
        Detail         string    `json:"detail"`
        Start          time.Time `json:"start"`
        End            time.Time `json:"end"`
        PsychologistID uint      `json:"psychologist_id"`
        PatientID      uint      `json:"patient_id"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
        return
    }

    db := config.DB()
    appointment := entity.Appointment{
        Title:          req.Title,
        Detail:         req.Detail,
        StartTime:      req.Start,
        EndTime:        req.End,
        PsychologistID: req.PsychologistID,
        PatientID:      req.PatientID,
        Status:         "pending",
    }
    if err := db.Create(&appointment).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create appointment"})
        return
    }

    // ‚úÖ ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á "‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢" ‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏µ‡∏¢‡πå p:{patient_id} ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö ws_uid
    log.Println("üì§ WS -> patient:", appointment.PatientID)
    ws.GlobalHub.SendToUser(patientPrefix+fmt.Sprint(appointment.PatientID), map[string]interface{}{
        "type":           "appointment_created",
        "title":          appointment.Title,
        "detail":         appointment.Detail,
        "start_time":     appointment.StartTime.Format(time.RFC3339),
        "end_time":       appointment.EndTime.Format(time.RFC3339),
        "appointment_id": appointment.ID,
        "status":         appointment.Status,
    })

    c.JSON(http.StatusCreated, gin.H{"id": appointment.ID})
}

// ========== ‡∏î‡∏∂‡∏á‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ô‡∏±‡∏Å‡∏à‡∏¥‡∏ï ==========
func GetAppointmentsByPsychologist(c *gin.Context) {
    id := c.Query("psychologist_id")
    db := config.DB()

    var appointments []entity.Appointment
    if err := db.Preload("Patient").Where("psychologist_id = ?", id).Find(&appointments).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve appointments"})
        return
    }
    c.JSON(http.StatusOK, appointments)
}

// ========== ‡∏î‡∏∂‡∏á‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏õ‡πà‡∏ß‡∏¢ ==========
func GetAppointmentsByPatient(c *gin.Context) {
    id := c.Query("patient_id")
    db := config.DB()

    var appointments []entity.Appointment
    if err := db.Preload("Psychologist").Where("patient_id = ?", id).Find(&appointments).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve appointments"})
        return
    }
    c.JSON(http.StatusOK, appointments)
}
func UpdateAppointmentStatus(c *gin.Context) {
    var req struct {
        ID     uint   `json:"id"`
        Status string `json:"status"` // accepted / rejected
        Reason string `json:"reason"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
        return
    }

    s := strings.ToLower(strings.TrimSpace(req.Status))
    if s != "accepted" && s != "rejected" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid status"})
        return
    }

    db := config.DB()

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏´‡∏°
    var ap entity.Appointment
    if err := db.First(&ap, req.ID).Error; err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Appointment not found"})
        return
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏ö‡∏ö‡πÄ‡∏ä‡πá‡∏Ñ‡∏ú‡∏•
    tx := db.Model(&entity.Appointment{}).
        Where("id = ?", req.ID).
        Updates(map[string]interface{}{"status": s, "reason": req.Reason})
    if tx.Error != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update status"})
        return
    }
    if tx.RowsAffected == 0 {
        c.JSON(http.StatusConflict, gin.H{"error": "No rows updated"})
        return
    }

    // ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö
    if err := db.First(&ap, req.ID).Error; err == nil {
        // ‡πÅ‡∏à‡πâ‡∏á WS ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á
        ws.GlobalHub.SendToUser(doctorPrefix+fmt.Sprint(ap.PsychologistID), map[string]interface{}{
            "type":           "appointment_status_changed",
            "appointment_id": ap.ID,
            "status":         ap.Status,
        })
        ws.GlobalHub.SendToUser(patientPrefix+fmt.Sprint(ap.PatientID), map[string]interface{}{
            "type":           "appointment_status_echo",
            "appointment_id": ap.ID,
            "status":         ap.Status,
        })
        c.JSON(http.StatusOK, gin.H{"message": "Status updated successfully", "appointment": ap})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Status updated successfully"})
}

// ========== ‡∏•‡∏ö‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢ ==========
func DeleteAppointment(c *gin.Context) {
    idParam := c.Param("id")
    id, err := strconv.ParseUint(idParam, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid appointment ID"})
        return
    }

    db := config.DB()
    if err := db.Delete(&entity.Appointment{}, id).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete appointment"})
        return
    }
    c.JSON(http.StatusOK, gin.H{"message": "Appointment deleted"})
}

// ========== ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°-‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î ==========
func UpdateAppointmentTime(c *gin.Context) {
    var req struct {
        ID       uint      `json:"id"`
        NewStart time.Time `json:"new_start"`
        NewEnd   time.Time `json:"new_end"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
        return
    }

    db := config.DB()
    var appointment entity.Appointment
    if err := db.First(&appointment, req.ID).Error; err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Appointment not found"})
        return
    }

    appointment.StartTime = req.NewStart
    appointment.EndTime = req.NewEnd
    if err := db.Save(&appointment).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update appointment time"})
        return
    }

    // ‚úÖ ‡πÅ‡∏à‡πâ‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ sync ‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô/‡∏Å‡∏≤‡∏£‡πå‡∏î
    payload := map[string]interface{}{
        "type":           "appointment_time_updated",
        "appointment_id": appointment.ID,
        "new_start":      appointment.StartTime.Format(time.RFC3339),
        "new_end":        appointment.EndTime.Format(time.RFC3339),
    }
    ws.GlobalHub.SendToUser(doctorPrefix+fmt.Sprint(appointment.PsychologistID), payload)
    ws.GlobalHub.SendToUser(patientPrefix+fmt.Sprint(appointment.PatientID), payload)

    c.JSON(http.StatusOK, gin.H{"message": "Appointment time updated"})
}
